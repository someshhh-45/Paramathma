<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ambulance Portal â€” TomTom Traffic Routing & Detection</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    body{font-family:Arial,Helvetica,sans-serif;background:#f4f6f8;padding:28px}
    .card{max-width:900px;margin:0 auto;background:#fff;padding:20px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    .btn{display:inline-block;padding:10px 14px;background:#3498db;color:#fff;border-radius:6px;text-decoration:none;border:none;cursor:pointer;margin:5px}
    .btn-danger{background:#e74c3c}
    .btn-success{background:#2ecc71}
    .btn-warning{background:#f39c12}
    .btn-muted{background:#95a5a6}
    .modal { display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); align-items:center; justify-content:center; z-index:9999 }
    .modal .box { background:#fff; padding:12px; border-radius:8px; max-width:920px; width:95%; max-height:90vh; overflow:auto; }
    #map { height:420px; border-radius:6px; margin-top:8px; }
    .meta { font-size:14px;color:#333;margin-top:8px; }
    .meta .bold { font-weight:700; color:#111; }
    input { padding:6px; border-radius:4px; border:1px solid #ddd; }
    pre { white-space:pre-wrap; }
    .traffic-section { margin-top:20px; padding:15px; background:#f8f9fa; border-radius:6px; }
    .traffic-item { padding:10px; margin:5px 0; background:#fff; border-left:4px solid #e74c3c; border-radius:4px; }
    .status-indicator { display:inline-block; width:12px; height:12px; border-radius:50%; margin-right:8px; }
    .status-active { background:#2ecc71; }
    .status-inactive { background:#95a5a6; }
    .traffic-controls { margin:10px 0; }
  </style>
</head>
<body>
  <div class="card">
    <h2>ðŸš‘ Ambulance Driver Portal (TomTom Traffic + Detection)</h2>
    <p>Live notification listener with traffic-aware routing and automatic traffic incident detection.</p>

    <label>
      <strong>Your ambulance row id in Baserow:</strong>
      <input id="rowId" placeholder="Enter row id" style="width:140px;margin-left:8px" />
    </label>
    <button class="btn" id="startBtn">Start Listening</button>
    <button class="btn btn-danger" id="stopBtn" style="display:none">Stop</button>

    <div class="traffic-controls">
      <button class="btn btn-warning" id="scanTrafficBtn">Scan for Traffic Incidents</button>
      <button class="btn btn-success" id="viewTrafficBtn">View Stored Traffic Data</button>
      <button class="btn" id="testDbBtn">Test Database Connection</button>
      <span class="status-indicator status-inactive" id="trafficScanStatus"></span>
      <span id="trafficScanText">Traffic scanning: Off</span>
    </div>

    <div style="margin-top:14px;color:#666">
      Tip: Put this page on the ambulance tablet and keep it open. Geolocation needs HTTPS (or localhost).
    </div>

    <div class="traffic-section" id="trafficSection" style="display:none">
      <h3>Traffic Incidents Detected</h3>
      <div id="trafficList"></div>
      <div style="margin-top:10px">
        
        <button class="btn btn-muted" id="clearTrafficBtn">Clear List</button>
      </div>
    </div>
  </div>

  <div id="modal" class="modal" aria-hidden="true">
    <div class="box">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 id="modalTitle">New Assignment</h3>
        <div>
          <button id="closeModal" class="btn btn-muted">Close</button>
        </div>
      </div>

      <pre id="modalBody" style="margin-top:8px;color:#111"></pre>

      <div id="map" style="display:none"></div>

      <div class="meta" id="routeMeta" style="display:none">
        <div><span class="bold">Distance:</span> <span id="metaDistance"></span></div>
        <div><span class="bold">Estimated time (traffic-aware):</span> <span id="metaDuration"></span></div>
        <div><span class="bold">Parsed ETA (notification):</span> <span id="metaETA"></span></div>
        <div><span class="bold">Traffic incidents on route:</span> <span id="metaTrafficCount">0</span></div>
      </div>

      <div style="margin-top:12px;text-align:right">
        <button id="ackBtn" class="btn" style="background:#2ecc71">Acknowledge & Clear</button>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ====== CONFIG - replace these ====== */
const CONFIG = {
  BASEROW_API_URL: 'https://api.baserow.io/api/database/rows/table/',
  BASEROW_TOKEN: 'QsQYhi1jNSzR0YroQunX3ZjJV4W9oja6',
  TABLE_IDS: { 
    AMBULANCES: '674303',
    TRAFFIC: '674305' // Your traffic table ID
  },
  TOMTOM_KEY: 'DIS5VKIuvmOXZdudysifhtzmvoK5hQqV'
};
/* =================================== */

let pollHandle = null;
let trafficScanHandle = null;
let lastNotification = null;
let map, routeLayer, markers = [], trafficMarkers = [];
let detectedTraffic = [];
let storedTrafficIncidents = [];

/* ---------- Baserow fetch functions ---------- */
async function getAmbulanceRow(rowId) {
  try {
    const url = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.AMBULANCES}/${rowId}/?user_field_names=true`;
    const res = await fetch(url, { headers: { 'Authorization': `Token ${CONFIG.BASEROW_TOKEN}` }});
    if (!res.ok) {
      console.error('getAmbulanceRow - non ok', res.status);
      return null;
    }
    return await res.json();
  } catch (err) {
    console.error('getAmbulanceRow error', err);
    return null;
  }
}

async function clearNotification(rowId) {
  try {
    const url = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.AMBULANCES}/${rowId}/?user_field_names=true`;
    const body = { "Notification": "" };
    const res = await fetch(url, {
      method: 'PATCH',
      headers: { 'Authorization': `Token ${CONFIG.BASEROW_TOKEN}`, 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    return res.ok;
  } catch (err) {
    console.error('clearNotification error', err);
    return false;
  }
}

/* ---------- Debug and Schema Functions ---------- */
async function getTrafficTableSchema() {
  try {
    const url = `https://api.baserow.io/api/database/fields/table/${CONFIG.TABLE_IDS.TRAFFIC}/`;
    const res = await fetch(url, { 
      headers: { 'Authorization': `Token ${CONFIG.BASEROW_TOKEN}` }
    });
    
    if (!res.ok) {
      console.error('Failed to get table schema:', res.status);
      return null;
    }
    
    const fields = await res.json();
    console.log('Traffic table schema:', fields);
    return fields;
  } catch (err) {
    console.error('getTrafficTableSchema error', err);
    return null;
  }
}

async function testDatabaseConnection() {
  console.log('ðŸ” Starting comprehensive database test...');
  
  // Test 1: Check API token and basic connection
  try {
    console.log('ðŸ“¡ Testing basic API connection...');
    const testUrl = `https://api.baserow.io/api/user/`;
    const testRes = await fetch(testUrl, { 
      headers: { 'Authorization': `Token ${CONFIG.BASEROW_TOKEN}` }
    });
    
    if (!testRes.ok) {
      console.error('âŒ API Token invalid or expired:', testRes.status);
      alert(`âŒ API Token Error (${testRes.status})\n\nYour Baserow API token appears to be invalid or expired. Please:\n1. Go to Baserow Settings â†’ API Tokens\n2. Generate a new token\n3. Update CONFIG.BASEROW_TOKEN in the code`);
      return false;
    }
    
    const userData = await testRes.json();
    console.log('âœ… API Token valid. User:', userData.first_name || userData.username);
    
  } catch (err) {
    console.error('âŒ Network/API connection failed:', err);
    alert('âŒ Network Error\n\nCannot connect to Baserow API. Check your internet connection.');
    return false;
  }
  
  // Test 2: Check table permissions
  try {
    console.log('ðŸ” Testing table read permissions...');
    const readUrl = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.TRAFFIC}/?user_field_names=true&size=1`;
    const readRes = await fetch(readUrl, { 
      headers: { 'Authorization': `Token ${CONFIG.BASEROW_TOKEN}` }
    });
    
    if (!readRes.ok) {
      const errorText = await readRes.text();
      console.error('âŒ Cannot read traffic table:', readRes.status, errorText);
      
      if (readRes.status === 404) {
        alert(`âŒ Table Not Found (404)\n\nTable ID ${CONFIG.TABLE_IDS.TRAFFIC} doesn't exist or you don't have access.\n\nPlease check:\n1. The table ID is correct\n2. Your API token has access to this table`);
      } else if (readRes.status === 401) {
        alert(`âŒ Unauthorized (401)\n\nYour API token doesn't have permission to access this table.\n\nPlease check your token permissions in Baserow Settings.`);
      }
      return false;
    }
    
    const readData = await readRes.json();
    console.log('âœ… Table read successful. Records found:', readData.count || 0);
    
  } catch (err) {
    console.error('âŒ Table read test failed:', err);
    return false;
  }
  
  // Test 3: Get exact field information
  try {
    console.log('ðŸ“‹ Getting table field information...');
    const fieldsUrl = `https://api.baserow.io/api/database/fields/table/${CONFIG.TABLE_IDS.TRAFFIC}/`;
    const fieldsRes = await fetch(fieldsUrl, { 
      headers: { 'Authorization': `Token ${CONFIG.BASEROW_TOKEN}` }
    });
    
    if (!fieldsRes.ok) {
      console.error('âš ï¸ Cannot get field info:', fieldsRes.status);
    } else {
      const fields = await fieldsRes.json();
      console.log('ðŸ“‹ Table fields:', fields);
      
      const fieldInfo = fields.map(f => `${f.name} (${f.type})`).join(', ');
      console.log('ðŸ“‹ Available fields:', fieldInfo);
    }
    
  } catch (err) {
    console.log('âš ï¸ Field info retrieval failed (not critical):', err);
  }
  
  // Test 4: Detailed write test with multiple approaches
  console.log('âœï¸ Testing write operations...');
  
  // Approach 1: Simple test record
  const testRecord1 = {
    "lat of T": "12.2958",
    "long of T": "76.6394", 
    "Details of T": `TEST RECORD 1 - ${new Date().toISOString()}`
  };
  
  const success1 = await attemptWrite(testRecord1, "Test 1 - Original field names");
  
  // Approach 2: Without user_field_names parameter
  if (!success1) {
    console.log('ðŸ”„ Trying without user_field_names parameter...');
    const success2 = await attemptWriteNoUserFieldNames(testRecord1, "Test 2 - No user_field_names");
    if (success2) return true;
  }
  
  // Approach 3: Try with numeric values instead of strings
  if (!success1) {
    const testRecord3 = {
      "lat of T": 12.2958,
      "long of T": 76.6394, 
      "Details of T": `TEST RECORD 3 - ${new Date().toISOString()}`
    };
    const success3 = await attemptWrite(testRecord3, "Test 3 - Numeric coordinates");
    if (success3) return true;
  }
  
  // Approach 4: Minimal record (only required fields)
  const testRecord4 = {
    "lat of T": "12.2958",
    "long of T": "76.6394"
  };
  const success4 = await attemptWrite(testRecord4, "Test 4 - Minimal record");
  
  if (success1 || success4) {
    return true;
  } else {
    console.log('âŒ All write tests failed');
    alert('âŒ All database write tests failed.\n\nPossible issues:\n1. Field validation rules in Baserow\n2. Required fields missing\n3. Data type mismatches\n4. Table permissions\n\nCheck the browser console for detailed error messages.');
    return false;
  }
}

async function attemptWrite(record, testName) {
  try {
    console.log(`ðŸ§ª ${testName}:`, record);
    
    const url = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.TRAFFIC}/?user_field_names=true`;
    const res = await fetch(url, {
      method: 'POST',
      headers: { 
        'Authorization': `Token ${CONFIG.BASEROW_TOKEN}`, 
        'Content-Type': 'application/json' 
      },
      body: JSON.stringify(record)
    });
    
    const responseText = await res.text();
    console.log(`ðŸ“¤ ${testName} - Status:`, res.status);
    console.log(`ðŸ“¤ ${testName} - Response:`, responseText);
    
    if (res.ok) {
      console.log(`âœ… ${testName} SUCCESS!`);
      const responseData = JSON.parse(responseText);
      alert(`âœ… Database Write Successful!\n\n${testName} worked.\nCreated record ID: ${responseData.id}`);
      
      // Clean up test record
      try {
        await deleteTestRecord(responseData.id);
      } catch (e) {
        console.log('Note: Could not delete test record (not critical)');
      }
      
      return true;
    } else {
      console.log(`âŒ ${testName} failed:`, responseText);
      
      // Parse specific error messages
      try {
        const errorData = JSON.parse(responseText);
        console.log(`âŒ ${testName} error details:`, errorData);
        
        if (errorData.error && errorData.error === "ERROR_REQUEST_BODY_VALIDATION") {
          console.log('âŒ Validation error - check field requirements in Baserow');
        }
      } catch (e) {
        // Response not JSON
      }
      
      return false;
    }
    
  } catch (err) {
    console.error(`âŒ ${testName} exception:`, err);
    return false;
  }
}

async function attemptWriteNoUserFieldNames(record, testName) {
  try {
    console.log(`ðŸ§ª ${testName}:`, record);
    
    const url = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.TRAFFIC}/`;
    const res = await fetch(url, {
      method: 'POST',
      headers: { 
        'Authorization': `Token ${CONFIG.BASEROW_TOKEN}`, 
        'Content-Type': 'application/json' 
      },
      body: JSON.stringify(record)
    });
    
    const responseText = await res.text();
    console.log(`ðŸ“¤ ${testName} - Status:`, res.status);
    console.log(`ðŸ“¤ ${testName} - Response:`, responseText);
    
    if (res.ok) {
      console.log(`âœ… ${testName} SUCCESS!`);
      alert(`âœ… Database Write Successful!\n\n${testName} worked.`);
      return true;
    } else {
      console.log(`âŒ ${testName} failed:`, responseText);
      return false;
    }
    
  } catch (err) {
    console.error(`âŒ ${testName} exception:`, err);
    return false;
  }
}

async function deleteTestRecord(recordId) {
  const url = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.TRAFFIC}/${recordId}/`;
  await fetch(url, {
    method: 'DELETE',
    headers: { 'Authorization': `Token ${CONFIG.BASEROW_TOKEN}` }
  });
}

async function saveTrafficIncidentTest() {
  const testData = {
    lat: 12.2958,
    lon: 76.6394,
    details: "Test traffic incident - " + new Date().toISOString(),
    severity: "test"
  };
  
  // Try multiple field name combinations
  const fieldCombinations = [
    { lat: "lat of T", lon: "long of T", details: "Details of T", notes: "Notes" },
 
  ];
  
  for (const fields of fieldCombinations) {
    try {
      const url = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.TRAFFIC}/?user_field_names=true`;
      
      const body = {
        [fields.lat]: testData.lat.toString(),
        [fields.lon]: testData.lon.toString(),
        [fields.details]: testData.details
      };
      
      // Add notes field if it exists 
      if (fields.notes) {
        body[fields.notes] = `Test entry - ${testData.severity}`;
      }
      
      console.log(`Trying field combination:`, fields);
      console.log(`Request body:`, body);
      
      const res = await fetch(url, {
        method: 'POST',
        headers: { 
          'Authorization': `Token ${CONFIG.BASEROW_TOKEN}`, 
          'Content-Type': 'application/json' 
        },
        body: JSON.stringify(body)
      });
      
      const responseText = await res.text();
      console.log(`Response (${res.status}):`, responseText);
      
      if (res.ok) {
        console.log(`âœ… SUCCESS! Working field names:`, fields);
        // Store working field names for future use
        window.workingFields = fields;
        alert(`âœ… Database connection successful!\nWorking field names: ${JSON.stringify(fields)}`);
        return true;
      } else {
        console.log(`âŒ Failed with fields:`, fields, 'Error:', responseText);
      }
      
    } catch (err) {
      console.log(`âŒ Error with fields:`, fields, err);
    }
  }
  
  alert('âŒ All field name combinations failed. Please check your table structure in Baserow.');
  return false;
}

async function loadStoredTraffic() {
  try {
    const url = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.TRAFFIC}/?user_field_names=true`;
    const res = await fetch(url, { headers: { 'Authorization': `Token ${CONFIG.BASEROW_TOKEN}` }});
    if (!res.ok) {
      console.error('loadStoredTraffic - non ok', res.status);
      return [];
    }
    const data = await res.json();
    return data.results || [];
  } catch (err) {
    console.error('loadStoredTraffic error', err);
    return [];
  }
}

async function saveTrafficIncident(lat, lon, details, severity = 'medium') {
  // Use working field names if we found them during testing
  const fields = window.workingFields || { 
    lat: "lat of T", 
    lon: "long of T", 
    details: "Details of T", 
    notes: "Notes" 
  };
  
  try {
    const url = `${CONFIG.BASEROW_API_URL}${CONFIG.TABLE_IDS.TRAFFIC}/?user_field_names=true`;
    
    const body = {
      [fields.lat]: parseFloat(lat).toString(),
      [fields.lon]: parseFloat(lon).toString(),
      [fields.details]: details || "Traffic incident detected"
    };
    
    if (fields.notes) {
      body[fields.notes] = `Auto-detected: ${new Date().toISOString()}, Severity: ${severity}`;
    }
    
    console.log('Saving traffic incident with fields:', fields);
    console.log('Request body:', body);
    
    const res = await fetch(url, {
      method: 'POST',
      headers: { 
        'Authorization': `Token ${CONFIG.BASEROW_TOKEN}`, 
        'Content-Type': 'application/json' 
      },
      body: JSON.stringify(body)
    });
    
    const responseText = await res.text();
    console.log('Save response:', res.status, responseText);
    
    if (!res.ok) {
      console.error('Save failed:', res.status, responseText);
      return false;
    }
    
    return true;
  } catch (err) {
    console.error('saveTrafficIncident error', err);
    return false;
  }
}

/* ---------- TomTom Traffic Flow API ---------- */
async function getTrafficIncidents(bbox) {
  if (!CONFIG.TOMTOM_KEY || CONFIG.TOMTOM_KEY === 'YOUR_TOMTOM_API_KEY') {
    console.error('TomTom key missing - set CONFIG.TOMTOM_KEY');
    return [];
  }
  
  // TomTom Traffic Incidents API
  // bbox format: minLon,minLat,maxLon,maxLat
  const url = `https://api.tomtom.com/traffic/services/5/incidentDetails?key=${CONFIG.TOMTOM_KEY}&bbox=${bbox}&fields={incidents{type,geometry{type,coordinates},properties{id,iconCategory,magnitudeOfDelay,events{description,code},startTime,endTime}}}&language=en-GB&categoryFilter=0,1,2,3,4,5,6,7,8,9,10,11`;
  
  try {
    const res = await fetch(url);
    if (!res.ok) {
      console.error('TomTom traffic API error', res.status);
      return [];
    }
    const data = await res.json();
    
    const incidents = [];
    if (data.incidents) {
      for (const incident of data.incidents) {
        if (incident.geometry && incident.geometry.coordinates) {
          let coords = incident.geometry.coordinates;
          let lat, lon;
          
          if (incident.geometry.type === 'Point') {
            [lon, lat] = coords;
          } else if (incident.geometry.type === 'LineString') {
            // Take the first point of the line
            [lon, lat] = coords[0];
          } else if (incident.geometry.type === 'Polygon') {
            // Take the first point of the first ring
            [lon, lat] = coords[0][0];
          } else {
            continue;
          }
          
          const properties = incident.properties || {};
          const events = properties.events || [];
          const description = events.length > 0 ? events[0].description : 'Traffic incident';
          const magnitude = properties.magnitudeOfDelay || 0;
          
          let severity = 'low';
          if (magnitude > 300) severity = 'high';      // > 5 min delay
          else if (magnitude > 120) severity = 'medium'; // > 2 min delay
          
          incidents.push({
            id: properties.id || `${lat}_${lon}_${Date.now()}`,
            lat: parseFloat(lat),
            lon: parseFloat(lon),
            description: description,
            magnitude: magnitude,
            severity: severity,
            iconCategory: properties.iconCategory,
            startTime: properties.startTime,
            endTime: properties.endTime,
            source: 'tomtom'
          });
        }
      }
    }
    
    return incidents;
  } catch (err) {
    console.error('getTrafficIncidents error', err);
    return [];
  }
}

/* ---------- Traffic scanning logic ---------- */
async function scanTrafficInArea(centerLat = 12.2958, centerLon = 76.6394, radiusKm = 10) {
  // Default coordinates are for Mysore, Karnataka - adjust as needed
  const kmToDegrees = radiusKm / 111.32; // Rough conversion
  const bbox = `${centerLon - kmToDegrees},${centerLat - kmToDegrees},${centerLon + kmToDegrees},${centerLat + kmToDegrees}`;
  
  console.log(`Scanning for traffic in area: ${bbox}`);
  
  const incidents = await getTrafficIncidents(bbox);
  console.log(`Found ${incidents.length} traffic incidents`);
  
  // Filter out incidents we already have
  const newIncidents = incidents.filter(inc => 
    !detectedTraffic.some(existing => 
      existing.id === inc.id || 
      (Math.abs(existing.lat - inc.lat) < 0.001 && Math.abs(existing.lon - inc.lon) < 0.001)
    )
  );
  
  detectedTraffic.push(...newIncidents);
  // Push new incidents to detectedTraffic
detectedTraffic.push(...newIncidents);
updateTrafficDisplay();

// Automatically save newly detected incidents
for (const incident of newIncidents) {
  saveTrafficIncident(
    incident.lat, 
    incident.lon, 
    incident.description, 
    incident.severity
  ).then(success => {
    if (success) console.log(`âœ“ Auto-saved incident at ${incident.lat}, ${incident.lon}`);
    else console.log(`âœ— Failed to auto-save incident at ${incident.lat}, ${incident.lon}`);
  });
}

  updateTrafficDisplay();
  
  return newIncidents;
}

function updateTrafficDisplay() {
  const trafficList = document.getElementById('trafficList');
  const trafficSection = document.getElementById('trafficSection');
  
  if (detectedTraffic.length === 0) {
    trafficSection.style.display = 'none';
    return;
  }
  
  trafficSection.style.display = 'block';
  trafficList.innerHTML = '';
  
  detectedTraffic.forEach((incident, index) => {
    const div = document.createElement('div');
    div.className = 'traffic-item';
    div.innerHTML = `
      <strong>${incident.severity.toUpperCase()} SEVERITY</strong> - ${incident.description}<br>
      <small>Location: ${incident.lat.toFixed(6)}, ${incident.lon.toFixed(6)}</small><br>
      <small>Delay: ${incident.magnitude ? `${Math.round(incident.magnitude/60)} min` : 'Unknown'} | Source: ${incident.source}</small>
      <button class="btn btn-muted" style="float:right;padding:2px 6px" onclick="removeTrafficIncident(${index})">Remove</button>
    `;
    trafficList.appendChild(div);
  });
}

function removeTrafficIncident(index) {
  detectedTraffic.splice(index, 1);
  updateTrafficDisplay();
}

async function saveAllTrafficIncidents() {
  if (detectedTraffic.length === 0) {
    alert('No traffic incidents to save');
    return;
  }
  
  let savedCount = 0;
  let failedIncidents = [];
  
  document.getElementById('saveTrafficBtn').innerText = 'Saving...';
  document.getElementById('saveTrafficBtn').disabled = true;
  
  for (const [index, incident] of detectedTraffic.entries()) {
    console.log(`Saving incident ${index + 1}/${detectedTraffic.length}:`, incident);
    
    const success = await saveTrafficIncident(
      incident.lat, 
      incident.lon, 
      incident.description, 
      incident.severity
    );
    
    if (success) {
      savedCount++;
      console.log(`âœ“ Saved incident ${index + 1}`);
    } else {
      failedIncidents.push(incident);
      console.log(`âœ— Failed to save incident ${index + 1}`);
    }
    
    // Small delay to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 500));
  }
  
  document.getElementById('saveTrafficBtn').innerText = 'Save New Incidents to Database';
  document.getElementById('saveTrafficBtn').disabled = false;
  
  if (savedCount > 0) {
    alert(`âœ“ Successfully saved ${savedCount} out of ${detectedTraffic.length} traffic incidents to database`);
    detectedTraffic = failedIncidents; // Keep only failed incidents
    updateTrafficDisplay();
    await loadAndDisplayStoredTraffic();
  } else {
    alert(`âœ— Failed to save any traffic incidents. Check console for error details.\n\nCommon issues:\n- Incorrect field names in database\n- API token permissions\n- Network connectivity`);
  }
  
  console.log('Save operation completed:', { savedCount, failed: failedIncidents.length });
}

async function loadAndDisplayStoredTraffic() {
  storedTrafficIncidents = await loadStoredTraffic();
  console.log(`Loaded ${storedTrafficIncidents.length} stored traffic incidents`);
}

/* ---------- Parsing helpers ---------- */
function parseLatLonFromText(text) {
  if (!text) return null;
  text = text.trim();
  let m = text.match(/(-?\d+\.\d+)\s*,\s*(-?\d+\.\d+)/);
  if (m) return { lat: parseFloat(m[1]), lon: parseFloat(m[2]) };
  m = text.match(/lat[:=]?\s*(-?\d+\.\d+)[\s,;]+(?:lon|lng)[:=]?\s*(-?\d+\.\d+)/i);
  if (m) return { lat: parseFloat(m[1]), lon: parseFloat(m[2]) };
  m = text.match(/POINT\(\s*(-?\d+\.\d+)\s+(-?\d+\.\d+)\s*\)/i);
  if (m) return { lat: parseFloat(m[2]), lon: parseFloat(m[1]) };
  return null;
}

function parseETAFromText(text) {
  if (!text) return null;
  let m = text.match(/ETA[:\s]*([0-9]+\s*(?:minutes|minute|min|m)|[0-9]+\s*h(?:ours?)?\s*[0-9]*\s*m?|[0-9]+)/i);
  if (m) return m[1].trim();
  return null;
}

/* ---------- Extract ambulance coords from row ---------- */
function extractAmbulanceCoords(row) {
  if (!row) return null;
  const latFieldCandidates = ['Latitude','latitude','Lat','lat','lat of A','lat_of_A','lat_of_a','latofa','lat of A'];
  const lonFieldCandidates = ['Longitude','longitude','Lon','lon','long of A','long_of_A','longofA','long of A','long of A '];
  for (const latKey of latFieldCandidates) {
    for (const lonKey of lonFieldCandidates) {
      if (row.hasOwnProperty(latKey) && row.hasOwnProperty(lonKey)) {
        const lat = parseFloat(row[latKey]);
        const lon = parseFloat(row[lonKey]);
        if (!isNaN(lat) && !isNaN(lon)) return { lat, lon, source: 'db', latKey, lonKey };
      }
    }
  }
  const locationFields = ['Location','location','Location of A','location_of_A','LocationA','Location A','Coordinates','coordinates','coords','Coords'];
  for (const k of locationFields) {
    if (row.hasOwnProperty(k) && row[k]) {
      const parsed = parseLatLonFromText(String(row[k]));
      if (parsed) return { lat: parsed.lat, lon: parsed.lon, source: 'db', field: k };
    }
  }
  return null;
}

/* ---------- Device geolocation fallback ---------- */
function getDeviceGeolocation(timeoutMs = 10000) {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) return reject(new Error('Geolocation not supported'));
    const opts = { enableHighAccuracy: true, timeout: timeoutMs, maximumAge: 0 };
    navigator.geolocation.getCurrentPosition(
      pos => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude, source: 'device' }),
      err => reject(err),
      opts
    );
  });
}

/* ---------- TomTom Calculate Route ---------- */
async function getRouteTomTom(from, to) {
  if (!CONFIG.TOMTOM_KEY || CONFIG.TOMTOM_KEY === 'YOUR_TOMTOM_API_KEY') {
    console.error('TomTom key missing - set CONFIG.TOMTOM_KEY');
    return null;
  }
  const start = `${from.lat},${from.lon}`;
  const end = `${to.lat},${to.lon}`;
  const url = `https://api.tomtom.com/routing/1/calculateRoute/${encodeURIComponent(start)}:${encodeURIComponent(end)}/json?key=${CONFIG.TOMTOM_KEY}&routeType=fastest&routeRepresentation=polyline&traffic=true`;
  try {
    const res = await fetch(url);
    if (!res.ok) {
      console.error('TomTom directions non-ok', res.status);
      const txt = await res.text();
      console.error(txt);
      return null;
    }
    const body = await res.json();
    if (!body.routes || body.routes.length === 0) return null;
    const r = body.routes[0];

    let distance_m = null;
    let duration_s = null;
    if (r.summary && r.summary.lengthInMeters != null) distance_m = r.summary.lengthInMeters;
    if (r.summary && r.summary.travelTimeInSeconds != null) duration_s = r.summary.travelTimeInSeconds;

    let coords = [];
    if (r.legs && Array.isArray(r.legs)) {
      for (const leg of r.legs) {
        if (leg.points && Array.isArray(leg.points)) {
          for (const p of leg.points) {
            if (p.latitude != null && p.longitude != null) coords.push([p.latitude, p.longitude]);
            else if (p.lat != null && p.lon != null) coords.push([p.lat, p.lon]);
            else if (Array.isArray(p) && p.length >= 2) coords.push([p[0], p[1]]);
          }
        }
      }
    }

    let geojson = null;
    if (coords.length > 0) {
      const line = coords.map(p => [parseFloat(p[1]), parseFloat(p[0])]);
      geojson = { type: "LineString", coordinates: line };
    }

    return { geojson, distance_m, duration_s, raw: r };
  } catch (e) {
    console.error('getRouteTomTom error', e);
    return null;
  }
}

/* ---------- Leaflet map functions ---------- */
function ensureMap() {
  if (!map) {
    map = L.map('map', { zoomControl: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);
  }
}

function showRouteOnMap(routeGeoJSON, from, to) {
  ensureMap();
  document.getElementById('map').style.display = 'block';
  if (routeLayer) { routeLayer.remove(); routeLayer = null; }
  routeLayer = L.geoJSON(routeGeoJSON, { style: { weight: 6, opacity: 0.9, color: '#2ecc71' } }).addTo(map);

  // Clear old markers
  markers.forEach(m => m.remove()); 
  markers = [];
  trafficMarkers.forEach(m => m.remove()); 
  trafficMarkers = [];

  // Add ambulance and destination markers
  const mFrom = L.marker([from.lat, from.lon]).addTo(map).bindPopup('Ambulance').openPopup();
  const mTo = L.marker([to.lat, to.lon]).addTo(map).bindPopup('User');
  markers.push(mFrom, mTo);

  // Add traffic incidents near route
  let trafficCount = 0;
  const allTraffic = [...detectedTraffic, ...storedTrafficIncidents];
  
  for (const incident of allTraffic) {
    // Simple proximity check - in real app, you'd check if traffic is actually on the route
    const distanceFromStart = Math.sqrt(Math.pow(incident.lat - from.lat, 2) + Math.pow(incident.lon - from.lon, 2));
    const distanceFromEnd = Math.sqrt(Math.pow(incident.lat - to.lat, 2) + Math.pow(incident.lon - to.lon, 2));
    
    if (distanceFromStart < 0.05 || distanceFromEnd < 0.05) { // Within ~5km radius
      trafficCount++;
      const color = incident.severity === 'high' ? 'red' : incident.severity === 'medium' ? 'orange' : 'yellow';
      const trafficIcon = L.divIcon({
        html: `<div style="background:${color};width:12px;height:12px;border-radius:50%;border:2px solid white;"></div>`,
        className: 'traffic-marker',
        iconSize: [16, 16]
      });
      
      const tMarker = L.marker([incident.lat, incident.lon], { icon: trafficIcon })
        .addTo(map)
        .bindPopup(`<b>Traffic Incident</b><br>${incident.description || incident['Details of T'] || 'No details'}<br><small>Severity: ${incident.severity || 'unknown'}</small>`);
      trafficMarkers.push(tMarker);
    }
  }
  
  document.getElementById('metaTrafficCount').innerText = trafficCount;

  const bounds = routeLayer.getBounds();
  if (bounds.isValid()) map.fitBounds(bounds.pad(0.15));
}

/* ---------- Utilities ---------- */
function formatDistance(m) { if (m >= 1000) return (m/1000).toFixed(1) + ' km'; return Math.round(m) + ' m'; }
function formatDuration(s) {
  if (s >= 3600) return Math.floor(s/3600) + ' h ' + Math.round((s%3600)/60) + ' min';
  if (s >= 60) return Math.round(s/60) + ' min';
  return Math.round(s) + ' s';
}
function showModal(text) {
  document.getElementById('modalBody').innerText = text;
  document.getElementById('modal').style.display = 'flex';
  document.getElementById('modal').setAttribute('aria-hidden','false');
  try { new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg').play(); } catch(e){}
}
function hideModal() {
  document.getElementById('modal').style.display = 'none';
  document.getElementById('modal').setAttribute('aria-hidden','true');
  document.getElementById('map').style.display = 'none';
  document.getElementById('routeMeta').style.display = 'none';
  if (routeLayer) { routeLayer.remove(); routeLayer = null; }
  markers.forEach(m => m.remove()); markers = [];
  trafficMarkers.forEach(m => m.remove()); trafficMarkers = [];
}

/* ---------- Poll + route logic ---------- */
async function poll(rowId) {
  const row = await getAmbulanceRow(rowId);
  if (!row) return;
  const noteRaw = (row['Notification'] || row['notification'] || '').trim();
  if (!noteRaw) return;
  if (noteRaw && noteRaw !== lastNotification) {
    lastNotification = noteRaw;
    showModal(noteRaw);

    const userCoords = parseLatLonFromText(noteRaw);
    const parsedETA = parseETAFromText(noteRaw);
    if (parsedETA) document.getElementById('metaETA').innerText = parsedETA;
    else document.getElementById('metaETA').innerText = 'â€”';

    if (!userCoords) {
      document.getElementById('modalBody').innerText = noteRaw + "\n\n(Unable to parse user coordinates from notification. Please include 'lat,lon' in dispatch.)";
      return;
    }

    let ambulanceCoords = extractAmbulanceCoords(row);
    if (!ambulanceCoords) {
      document.getElementById('modalBody').innerText = noteRaw + "\n\n(Ambulance coordinates not found in DB. Attempting to get device GPS â€” please allow location permission.)";
      try {
        ambulanceCoords = await getDeviceGeolocation();
      } catch (geErr) {
        console.error('Device geolocation failed:', geErr);
        document.getElementById('modalBody').innerText = noteRaw + "\n\n(Unable to read ambulance coordinates from DB and device GPS is unavailable/denied. Add coordinate fields to the row or allow GPS.)";
        return;
      }
    }

    // Get route
    const route = await getRouteTomTom(ambulanceCoords, userCoords);
    if (!route) {
      document.getElementById('modalBody').innerText = noteRaw + "\n\n(Unable to compute route via TomTom. Check key/quota.)";
      return;
    }

    // Display results
    document.getElementById('modalBody').innerText = noteRaw;
    document.getElementById('routeMeta').style.display = 'block';
    document.getElementById('metaDistance').innerText = route.distance_m ? formatDistance(route.distance_m) : 'â€”';
    document.getElementById('metaDuration').innerText = route.duration_s ? formatDuration(route.duration_s) : 'â€”';

    if (route.geojson) {
      let gj = route.geojson;
      if (gj.type === 'LineString') {
        gj = { type: 'Feature', geometry: gj, properties: {} };
      }
      showRouteOnMap(gj, ambulanceCoords, userCoords);
    } else {
      document.getElementById('modalBody').innerText += "\n\n(Route computed but no drawable geometry returned.)";
    }
    
    // Auto-scan for traffic incidents around the route
    const midLat = (ambulanceCoords.lat + userCoords.lat) / 2;
    const midLon = (ambulanceCoords.lon + userCoords.lon) / 2;
    await scanTrafficInArea(midLat, midLon, 5); // 5km radius around route
  }
}

/* ---------- Event handlers ---------- */
document.getElementById('startBtn').addEventListener('click', () => {
  const rowId = document.getElementById('rowId').value.trim();
  if (!rowId) return alert('Enter your Baserow row id');
  if (pollHandle) clearInterval(pollHandle);
  pollHandle = setInterval(() => poll(rowId), 3000);
  poll(rowId);
  document.getElementById('startBtn').style.display = 'none';
  document.getElementById('stopBtn').style.display = 'inline-block';
});

document.getElementById('stopBtn').addEventListener('click', () => {
  if (pollHandle) clearInterval(pollHandle);
  pollHandle = null;
  if (trafficScanHandle) clearInterval(trafficScanHandle);
  trafficScanHandle = null;
  document.getElementById('startBtn').style.display = 'inline-block';
  document.getElementById('stopBtn').style.display = 'none';
  document.getElementById('trafficScanStatus').className = 'status-indicator status-inactive';
  document.getElementById('trafficScanText').innerText = 'Traffic scanning: Off';
  lastNotification = null;
});

document.getElementById('scanTrafficBtn').addEventListener('click', async () => {
  if (trafficScanHandle) {
    // Stop scanning
    clearInterval(trafficScanHandle);
    trafficScanHandle = null;
    document.getElementById('scanTrafficBtn').innerText = 'Scan for Traffic Incidents';
    document.getElementById('trafficScanStatus').className = 'status-indicator status-inactive';
    document.getElementById('trafficScanText').innerText = 'Traffic scanning: Off';
  } else {
    // Start scanning
    document.getElementById('scanTrafficBtn').innerText = 'Stop Traffic Scanning';
    document.getElementById('trafficScanStatus').className = 'status-indicator status-active';
    document.getElementById('trafficScanText').innerText = 'Traffic scanning: Active';
    
    // Initial scan
    await scanTrafficInArea();
    
    // Set up interval scanning every 2 minutes
    trafficScanHandle = setInterval(async () => {
      await scanTrafficInArea();
    }, 120000);
  }
});

document.getElementById('viewTrafficBtn').addEventListener('click', async () => {
  await loadAndDisplayStoredTraffic();
  alert(`Loaded ${storedTrafficIncidents.length} stored traffic incidents from database. Check console for details.`);
  console.table(storedTrafficIncidents);
});

document.getElementById('saveTrafficBtn').addEventListener('click', saveAllTrafficIncidents);

document.getElementById('clearTrafficBtn').addEventListener('click', () => {
  detectedTraffic = [];
  updateTrafficDisplay();
});

document.getElementById('testDbBtn').addEventListener('click', async () => {
  document.getElementById('testDbBtn').innerText = 'Testing...';
  document.getElementById('testDbBtn').disabled = true;
  
  const success = await testDatabaseConnection();
  
  document.getElementById('testDbBtn').innerText = 'Test Database Connection';
  document.getElementById('testDbBtn').disabled = false;
  
  if (success) {
    console.log('âœ… Database test completed successfully');
  } else {
    console.log('âŒ Database test failed');
  }
});

document.getElementById('ackBtn').addEventListener('click', async () => {
  const rowId = document.getElementById('rowId').value.trim();
  if (!rowId) return;
  await clearNotification(rowId);
  hideModal();
});

document.getElementById('closeModal').addEventListener('click', hideModal);

// Initialize on page load
document.addEventListener('DOMContentLoaded', async () => {
  console.log('Ambulance Portal with Traffic Detection initialized');
  await loadAndDisplayStoredTraffic();
  
  // Optional: Start with a small traffic scan in default area
  try {
    await scanTrafficInArea();
  } catch (err) {
    console.log('Initial traffic scan failed - this is normal if TomTom key is not configured');
  }
});
</script>

</body>
</html>